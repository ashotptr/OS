3)
//////////////////////////////////////////////////////////////
nm main.o
0000000000000000 T main
                 U printf
                 U square
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
nm math_utils.o
0000000000000000 T square
//////////////////////////////////////////////////////////////        

//////////////////////////////////////////////////////////////
nm square_prog
0000000000003dc8 d _DYNAMIC
0000000000003fb8 d _GLOBAL_OFFSET_TABLE_
0000000000002000 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000002128 r __FRAME_END__
0000000000002020 r __GNU_EH_FRAME_HDR
0000000000004010 D __TMC_END__
000000000000038c r __abi_tag
0000000000004010 B __bss_start
                 w __cxa_finalize@GLIBC_2.2.5
0000000000004000 D __data_start
0000000000001100 t __do_global_dtors_aux
0000000000003dc0 d __do_global_dtors_aux_fini_array_entry
0000000000004008 D __dso_handle
0000000000003db8 d __frame_dummy_init_array_entry
                 w __gmon_start__
                 U __libc_start_main@GLIBC_2.34
0000000000004010 D _edata
0000000000004018 B _end
00000000000011a0 T _fini
0000000000001000 T _init
0000000000001060 T _start
0000000000004010 b completed.0
0000000000004000 W data_start
0000000000001090 t deregister_tm_clones
0000000000001140 t frame_dummy
0000000000001149 T main
                 U printf@GLIBC_2.2.5
00000000000010c0 t register_tm_clones
000000000000118c T square
//////////////////////////////////////////////////////////////

4)
//////////////////////////////////////////////////////////////
objdump -d main.o

main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   c7 45 f8 05 00 00 00    movl   $0x5,-0x8(%rbp)
  13:   8b 45 f8                mov    -0x8(%rbp),%eax
  16:   89 c7                   mov    %eax,%edi
  18:   e8 00 00 00 00          call   1d <main+0x1d>
  1d:   89 45 fc                mov    %eax,-0x4(%rbp)
  20:   8b 55 fc                mov    -0x4(%rbp),%edx
  23:   8b 45 f8                mov    -0x8(%rbp),%eax
  26:   89 c6                   mov    %eax,%esi
  28:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 2f <main+0x2f>
  2f:   48 89 c7                mov    %rax,%rdi
  32:   b8 00 00 00 00          mov    $0x0,%eax
  37:   e8 00 00 00 00          call   3c <main+0x3c>
  3c:   b8 00 00 00 00          mov    $0x0,%eax
  41:   c9                      leave
  42:   c3                      ret
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
objdump -d math_utils.o

math_utils.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <square>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   89 7d fc                mov    %edi,-0x4(%rbp)
   b:   8b 45 fc                mov    -0x4(%rbp),%eax
   e:   0f af c0                imul   %eax,%eax
  11:   5d                      pop    %rbp
  12:   c3                      ret
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
objdump -d square_prog

square_prog:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret

Disassembly of section .plt:

0000000000001020 <.plt>:
    1020:       ff 35 9a 2f 00 00       push   0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:       ff 25 9c 2f 00 00       jmp    *0x2f9c(%rip)        # 3fc8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:       0f 1f 40 00             nopl   0x0(%rax)
    1030:       f3 0f 1e fa             endbr64
    1034:       68 00 00 00 00          push   $0x0
    1039:       e9 e2 ff ff ff          jmp    1020 <_init+0x20>
    103e:       66 90                   xchg   %ax,%ax

Disassembly of section .plt.got:

0000000000001040 <__cxa_finalize@plt>:
    1040:       f3 0f 1e fa             endbr64
    1044:       ff 25 ae 2f 00 00       jmp    *0x2fae(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>
    104a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000001050 <printf@plt>:
    1050:       f3 0f 1e fa             endbr64
    1054:       ff 25 76 2f 00 00       jmp    *0x2f76(%rip)        # 3fd0 <printf@GLIBC_2.2.5>
    105a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

Disassembly of section .text:

0000000000001060 <_start>:
    1060:       f3 0f 1e fa             endbr64
    1064:       31 ed                   xor    %ebp,%ebp
    1066:       49 89 d1                mov    %rdx,%r9
    1069:       5e                      pop    %rsi
    106a:       48 89 e2                mov    %rsp,%rdx
    106d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
    1071:       50                      push   %rax
    1072:       54                      push   %rsp
    1073:       45 31 c0                xor    %r8d,%r8d
    1076:       31 c9                   xor    %ecx,%ecx
    1078:       48 8d 3d ca 00 00 00    lea    0xca(%rip),%rdi        # 1149 <main>
    107f:       ff 15 53 2f 00 00       call   *0x2f53(%rip)        # 3fd8 <__libc_start_main@GLIBC_2.34>
    1085:       f4                      hlt
    1086:       66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)
    108d:       00 00 00

0000000000001090 <deregister_tm_clones>:
    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        # 4010 <__TMC_END__>
    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        # 4010 <__TMC_END__>
    109e:       48 39 f8                cmp    %rdi,%rax
    10a1:       74 15                   je     10b8 <deregister_tm_clones+0x28>
    10a3:       48 8b 05 36 2f 00 00    mov    0x2f36(%rip),%rax        # 3fe0 <_ITM_deregisterTMCloneTable@Base>
    10aa:       48 85 c0                test   %rax,%rax
    10ad:       74 09                   je     10b8 <deregister_tm_clones+0x28>
    10af:       ff e0                   jmp    *%rax
    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    10b8:       c3                      ret
    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

00000000000010c0 <register_tm_clones>:
    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        # 4010 <__TMC_END__>
    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        # 4010 <__TMC_END__>
    10ce:       48 29 fe                sub    %rdi,%rsi
    10d1:       48 89 f0                mov    %rsi,%rax
    10d4:       48 c1 ee 3f             shr    $0x3f,%rsi
    10d8:       48 c1 f8 03             sar    $0x3,%rax
    10dc:       48 01 c6                add    %rax,%rsi
    10df:       48 d1 fe                sar    $1,%rsi
    10e2:       74 14                   je     10f8 <register_tm_clones+0x38>
    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        # 3ff0 <_ITM_registerTMCloneTable@Base>
    10eb:       48 85 c0                test   %rax,%rax
    10ee:       74 08                   je     10f8 <register_tm_clones+0x38>
    10f0:       ff e0                   jmp    *%rax
    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    10f8:       c3                      ret
    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000001100 <__do_global_dtors_aux>:
    1100:       f3 0f 1e fa             endbr64
    1104:       80 3d 05 2f 00 00 00    cmpb   $0x0,0x2f05(%rip)        # 4010 <__TMC_END__>
    110b:       75 2b                   jne    1138 <__do_global_dtors_aux+0x38>
    110d:       55                      push   %rbp
    110e:       48 83 3d e2 2e 00 00    cmpq   $0x0,0x2ee2(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>
    1115:       00
    1116:       48 89 e5                mov    %rsp,%rbp
    1119:       74 0c                   je     1127 <__do_global_dtors_aux+0x27>
    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        # 4008 <__dso_handle>
    1122:       e8 19 ff ff ff          call   1040 <__cxa_finalize@plt>
    1127:       e8 64 ff ff ff          call   1090 <deregister_tm_clones>
    112c:       c6 05 dd 2e 00 00 01    movb   $0x1,0x2edd(%rip)        # 4010 <__TMC_END__>
    1133:       5d                      pop    %rbp
    1134:       c3                      ret
    1135:       0f 1f 00                nopl   (%rax)
    1138:       c3                      ret
    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000001140 <frame_dummy>:
    1140:       f3 0f 1e fa             endbr64
    1144:       e9 77 ff ff ff          jmp    10c0 <register_tm_clones>

0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    1155:       c7 45 f8 05 00 00 00    movl   $0x5,-0x8(%rbp)
    115c:       8b 45 f8                mov    -0x8(%rbp),%eax
    115f:       89 c7                   mov    %eax,%edi
    1161:       e8 26 00 00 00          call   118c <square>
    1166:       89 45 fc                mov    %eax,-0x4(%rbp)
    1169:       8b 55 fc                mov    -0x4(%rbp),%edx
    116c:       8b 45 f8                mov    -0x8(%rbp),%eax
    116f:       89 c6                   mov    %eax,%esi
    1171:       48 8d 05 8c 0e 00 00    lea    0xe8c(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1178:       48 89 c7                mov    %rax,%rdi
    117b:       b8 00 00 00 00          mov    $0x0,%eax
    1180:       e8 cb fe ff ff          call   1050 <printf@plt>
    1185:       b8 00 00 00 00          mov    $0x0,%eax
    118a:       c9                      leave
    118b:       c3                      ret

000000000000118c <square>:
    118c:       f3 0f 1e fa             endbr64
    1190:       55                      push   %rbp
    1191:       48 89 e5                mov    %rsp,%rbp
    1194:       89 7d fc                mov    %edi,-0x4(%rbp)
    1197:       8b 45 fc                mov    -0x4(%rbp),%eax
    119a:       0f af c0                imul   %eax,%eax
    119d:       5d                      pop    %rbp
    119e:       c3                      ret

Disassembly of section .fini:

00000000000011a0 <_fini>:
    11a0:       f3 0f 1e fa             endbr64
    11a4:       48 83 ec 08             sub    $0x8,%rsp
    11a8:       48 83 c4 08             add    $0x8,%rsp
    11ac:       c3                      ret
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
Explanation:
Object Files (main.o, math_utils.o) are compiled machine code for a single source file, but they are not yet a complete, runnable program.
The objdump output for main.o has a call to the square function that doesn't point anywhere meaningful yet.
18: e8 00 00 00 00   call   1d <main+0x1d>
The linker's job is to replace 00 00 00 00 with the real address of the square function.
Also there is no entry point, object files have no concept of a program starting point. There is no _start code, which is required to begin execution.

The final executable is the result of the linker combining all the object files and linking them with necessary libraries.
It's a complete, self-contained, and runnable program.
The objdump output for square_prog shows that the linker has filled in the placeholder.
The call instruction in main now points to the exact, final virtual memory address of the square function.
1161: e8 26 00 00 00   call   118c <square>
Also there is _start: which is the entry point of the program that the operating system kernel jumps to. This code sets up the environment and then calls the main function.
//////////////////////////////////////////////////////////////

5)
//////////////////////////////////////////////////////////////
readelf -h main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          704 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 13
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
readelf -h math_utils.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          464 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 11
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
readelf -h square_prog
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
  Start of program headers:          64 (bytes into file)
  Start of section headers:          14048 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
readelf -S main.o
There are 14 section headers, starting at offset 0x2c0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000043  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000001e8
       0000000000000048  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000083
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  00000083
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .rodata           PROGBITS         0000000000000000  00000083
       0000000000000019  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  0000009c
       000000000000002c  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000c8
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  000000c8
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  000000e8
       0000000000000038  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  00000230
       0000000000000018  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  00000120
       00000000000000a8  0000000000000018          12     4     8
  [12] .strtab           STRTAB           0000000000000000  000001c8
       000000000000001b  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  00000248
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
readelf -S math_utils.o
There are 12 section headers, starting at offset 0x1d0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000013  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .comment          PROGBITS         0000000000000000  00000053
       000000000000002c  0000000000000001  MS       0     0     1
  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  0000007f
       0000000000000000  0000000000000000           0     0     1
  [ 6] .note.gnu.pr[...] NOTE             0000000000000000  00000080
       0000000000000020  0000000000000000   A       0     0     8
  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a0
       0000000000000038  0000000000000000   A       0     0     8
  [ 8] .rela.eh_frame    RELA             0000000000000000  00000150
       0000000000000018  0000000000000018   I       9     7     8
  [ 9] .symtab           SYMTAB           0000000000000000  000000d8
       0000000000000060  0000000000000018          10     3     8
  [10] .strtab           STRTAB           0000000000000000  00000138
       0000000000000015  0000000000000000           0     0     1
  [11] .shstrtab         STRTAB           0000000000000000  00000168
       0000000000000067  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
readelf -S square_prog
There are 31 section headers, starting at offset 0x36e0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338
       0000000000000030  0000000000000000   A       0     0     8
  [ 3] .note.gnu.bu[...] NOTE             0000000000000368  00000368
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000000038c  0000038c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000000003b0  000003b0
       0000000000000024  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           00000000000003d8  000003d8
       00000000000000a8  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           0000000000000480  00000480
       000000000000008f  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           0000000000000510  00000510
       000000000000000e  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520
       0000000000000030  0000000000000000   A       7     1     8
  [10] .rela.dyn         RELA             0000000000000550  00000550
       00000000000000c0  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             0000000000000610  00000610
       0000000000000018  0000000000000018  AI       6    24     8
  [12] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000001020  00001020
       0000000000000020  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000001040  00001040
       0000000000000010  0000000000000010  AX       0     0     16
  [15] .plt.sec          PROGBITS         0000000000001050  00001050
       0000000000000010  0000000000000010  AX       0     0     16
  [16] .text             PROGBITS         0000000000001060  00001060
       000000000000013f  0000000000000000  AX       0     0     16
  [17] .fini             PROGBITS         00000000000011a0  000011a0
       000000000000000d  0000000000000000  AX       0     0     4
  [18] .rodata           PROGBITS         0000000000002000  00002000
       000000000000001d  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002020  00002020
       000000000000003c  0000000000000000   A       0     0     4
  [20] .eh_frame         PROGBITS         0000000000002060  00002060
       00000000000000cc  0000000000000000   A       0     0     8
  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8
       00000000000001f0  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000003fb8  00002fb8
       0000000000000048  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000004010  00003010
       0000000000000008  0000000000000000  WA       0     0     1
  [27] .comment          PROGBITS         0000000000000000  00003010
       000000000000002b  0000000000000001  MS       0     0     1
  [28] .symtab           SYMTAB           0000000000000000  00003040
       0000000000000390  0000000000000018          29    19     8
  [29] .strtab           STRTAB           0000000000000000  000033d0
       00000000000001f0  0000000000000000           0     0     1
  [30] .shstrtab         STRTAB           0000000000000000  000035c0
       000000000000011a  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
The object files are the raw, compiled output for a single source file.
They contain the code and data from their respective .c files, with instructions for the linker on how to piece them together.

.text section contains the actual executable machine code for the functions, main in main.o and square in math_utils.o.
There are also flags A and X which mean that the section should be allocated in memory and is executable.

.data section stores initialized global and static variables.
The program doesn't have any, so the size is zero for all files.
This section has W and A flags. A means that the section should be allocated in memory, W means it should be writable.

.bss section is for uninitialized global and static variables.
The BSS section is a placeholder, which means it doesn't take up space in the object file itself but tells the loader to reserve a certain amount of zero-filled memory when the program runs.
This is indicated by NOBITS.

.rodata is the Read-Only Data section.
It holds constant values, most commonly string literals.
In main.o, the format string "The square of %d is %d.\n" is stored here.

.symtab is the Symbol Table.
It's s list of all the functions and variables that are defined in this file or referenced by it.
nm command uses the information in this section.


The executable is ready to be executed. At this stage the linker has combined the object files and resolved all the symbols.

.text section is now larger.
It contains the code from main.o and math_utils.o combined together, with startup code (_start) and other necessary functions.
Also the address is no longer zero.
It shows the final virtual memory address where the code will live when the program runs in my case 0x0000000000001060.

.rodata, .data, .bss have also been combined from all object files and given final memory addresses.
//////////////////////////////////////////////////////////////
6)
//////////////////////////////////////////////////////////////
The nm output shows the symbols in the file.

In main.o:

For "T main" the symbol main is defined (T) in this file's text section. 
Its address is 0000000000000000, but it is relocatable and the final memory location is unknown.

For "U printf/U square" the symbols printf and square are undefined (U). 
The code in main.c calls these functions, but their definitions are not in this file. 
It is the linker's job to find them.


In math_utils.o:

For "T square" the symbol square is defined (T) here. 
This provides the definition that main.o was missing.


In the square_prog Executable:

For "T main/T square" both symbols are now defined and have been assigned final virtual memory addresses (0000000000001149 and 000000000000118c). 
The linker has placed the code from both object files into a single layout.

For "U printf@GLIBC_2.2.5" the printf symbol is still marked as undefined, but it has been resolved for dynamic linking. 
The @GLIBC_2.2.5 indicates that the linker has set up a placeholder (in the Procedure Linkage Table) so that the actual address of printf from the shared C library will be looked up by the dynamic loader when the program is run.

There are also new symbols (_start, _init, _fini). 
The executable contains many new symbols not present in our object files. 
But the most important is _start, which is the entry point of the program. 
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
For .o files the objdump -d command disassembles the .text (executable code) section, showing us raw machine instructions and assembly code. 

In main.o, the disassembly shows that the compiler has generated the machine code for the main function, but it doesn't know the final memory addresses for the functions it needs to call. 
18:   e8 00 00 00 00          call   1d <main+0x1d>
37:   e8 00 00 00 00          call   3c <main+0x3c>
The instructions to call the square function and printf function have a placeholder offset of all zeros (00 00 00 00).

The disassembly of the final square_prog executable shows that the linker has completed its work and shows the final address.

0000000000001149 <main>:
1161:       e8 26 00 00 00          call   118c <square>
1180:       e8 cb fe ff ff          call   1050 <printf@plt>
000000000000118c <square>:

Also the .text sections from main.o and math_utils.o have been combined. 
We can now see the complete machine code for both the main function and the square function within the same disassembly.
The linker has replaced the placeholder (00 00 00 00) with a specific, calculated offset (26 00 00 00).

The call to printf has also been relocated. 
It now points to an address within the Procedure Linkage Table (.plt). 
This is a section created by the linker to handle calls to functions in shared libraries, which will be resolved by the dynamic linker at runtime.

The executable's disassembly contains a _start section, which is the program's entry point. 
This code is not present in the object file.
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
The readelf output shows metadatada information about object files and the executable.

The object files (.o) are of type REL (Relocatable file) and have an entry point address of 0x0. 
They are not runnable and are just a collections of code and data.

The executable (square_prog) is of type DYN (Position-Independent Executable file) and has a specific entry point address (0x1060). 
This address points to the _start code, and not our main function.


The executable's sections (.text, .rodata, etc.) are a merged version of the sections from main.o and math_utils.o.

Also object files contain relocation sections (.rela.text, etc.). 
These sections contain the instructions for the linker. 
In my case it specifies that the call instruction in main.o needs to be updated with the final address of the square function. 

These relocation sections that exist in .o files do not exist in the final executable, because they have already served their purpose.
But the excutable can still contain sections like .rela.dyn and .rela.plt that are used by the dynamic linker at runtime.
The executable contains many new sections required to run the program.
For example .interp specifies the path to the dynamic linker, .plt and .got (The Procedure Linkage Table and Global Offset Table), are used to handle calls to shared library functions like printf, etc.
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
The linking process is the final step that transforms isolated, incomplete object files into a single, runnable program.
The linker's first job is to create a complete symbol map. 
It reads the symbol tables of all object files and libraries, matching every undefined reference (U) in one file to a defined symbol (T or D) in another. 
If any symbol remains undefined, the linker gives an error.
Using the information from the relocation sections (.rela.text), it calculates the final virtual addresses for all functions and data and updates the placeholder addresses. 
The objdump output shosw it.
In main.o, the call is unresolved (e8 00 00 00 00          call   1d <main+0x1d>).
And in square_prog, the linker has given it the final address of square (e8 26 00 00 00          call   118c <square>)
The linker also combines all sections of the same type (.text sections, .data sections, etc.) into single sections in the final executable. 
The linker also adds the C runtime startup code (_start).
//////////////////////////////////////////////////////////////
