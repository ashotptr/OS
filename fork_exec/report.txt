1)multiple_fork
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <sys/wait.h>

int main()
{
    printf("Starting Program -> PID: %d\n", getpid());
    printf("----------------------------------\n");

    pid_t pid1 = fork();
    if (pid1 < 0) {
        perror("fork 1 failed");
        exit(1);
    }

    if (pid1 == 0) {
        printf("Fork 1 Child -> My PID is %d, my parent is %d\n", getpid(), getppid());
    } else {
        printf("Fork 1 Parent -> My PID is %d, I created child %d\n", getpid(), pid1);
	    wait(NULL);
    }

    pid_t pid2 = fork();
    if (pid2 < 0) {
        perror("fork 2 failed");
        exit(1);
    }

    if (pid2 == 0) {
        printf("Fork 2 Child -> My PID is %d, my parent is %d\n", getpid(), getppid());
    } else {
        printf("Fork 2 Parent -> My PID is %d, I created child %d\n", getpid(), pid2);
	    wait(NULL);
    }

    pid_t pid3 = fork();
    if (pid3 < 0) {
        perror("fork 3 failed");
        exit(1);
    }

    if (pid3 == 0) {
        printf("Fork 3 Child -> My PID is %d, my parent is %d\n", getpid(), getppid());
    } else {
        printf("Fork 3 Parent -> My PID is %d, I created child %d\n", getpid(), pid3);
	    wait(NULL);
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We print the process id of the starting program. 
Then do "fork", which creates a new child process, which is duplicate of the parent, except of its process id. 
The "fork" call produces process id, it is 0 for a child process, smaller that 0 when the fork call was not successful, and for the parent process it is the process id of the newly created child.
For a child process we print its and its parent process's id.
For a parent process we print its id and child's id, which is "pid1", and use "wait" to wait untill child process finishes execution and get to zombie state.
After child porcess's execution end, the parent process will continue its execution.
For the second fork the child process with process id of "pid1" becomes a parent process for a new child process with pid of "pid2".
And in this way process tree is being created where each process creates two new, and each one of those two create two new each as well.
This happens three times.
The result of the prints is the following:
-----------------------------
Starting Program -> PID: 143540
----------------------------------
Fork 1 Parent -> My PID is 143540, I created child 143541
Fork 1 Child -> My PID is 143541, my parent is 143540
Fork 2 Parent -> My PID is 143541, I created child 143542
Fork 2 Child -> My PID is 143542, my parent is 143541
Fork 3 Parent -> My PID is 143542, I created child 143543
Fork 3 Child -> My PID is 143543, my parent is 143542
Fork 3 Parent -> My PID is 143541, I created child 143544
Fork 3 Child -> My PID is 143544, my parent is 143541
Fork 2 Parent -> My PID is 143540, I created child 143545
Fork 2 Child -> My PID is 143545, my parent is 143540
Fork 3 Parent -> My PID is 143545, I created child 143546
Fork 3 Child -> My PID is 143546, my parent is 143545
Fork 3 Parent -> My PID is 143540, I created child 143547
Fork 3 Child -> My PID is 143547, my parent is 143540
-----------------------------
We can see that overall 7 new processes were created, and it makes total of 8 processes.
This is because number of process and number of forks have the following relationship: process_num = 2 ^ fork_num, (when forks were all successful) 

2)simple_fork_exec
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("Child process is running the 'ls' command...\n");
        printf("--------------------------------------------------\n");

        execl("/bin/ls", "ls", NULL);

        perror("execl failed");
        exit(1);
    }
    else {
        wait(NULL);

        printf("--------------------------------------------------\n");
        printf("Parent process: Child has finished.\n");
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We start by forking and creating a new process, check for the case when it failed, print a message and exit with code 1 which indicates failure in the execution of the program.
For the child case when "pid" is 0, we print some text, and call execl, which replaces the current process image with a new one, and keeps "pid".
In this case the new program is "ls" which is located in "/bin/ls". And NULL tells that it is the end of argument list.
"perror" and "exit" will happen if something went wrong in "execl", and will make the process exit with a code 1.
For the parent process we wait untli child process completes and goes into zombie state and then print the text.
The result of the prints is the following:
-----------------------------
Child process is running the 'ls' command...
--------------------------------------------------
simple_fork_exec  simple_fork_exec.c
--------------------------------------------------
Parent process: Child has finished.
-----------------------------
We ran "ls" as a child process and it showed the contents of the current directory. After it completed we saw parent's message.

3)multiple_fork_exec
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid1, pid2;

    printf("Parent starting...\n\n");

    pid1 = fork();

    if (pid1 < 0) {
        perror("fork 1 failed");
        exit(1);
    }

    if (pid1 == 0) {
        printf("Child 1 (PID: %d) is running 'ls'...\n", getpid());
        printf("----------------------------------------\n");
        execl("/bin/ls", "ls", NULL);

        perror("execl for ls failed");
        exit(1);
    } else {
        wait(NULL);
        printf("----------------------------------------\n");
        printf("Parent: Child 1 has finished.\n\n");
    }

    pid2 = fork();

    if (pid2 < 0) {
        perror("fork 2 failed");
        exit(1);
    }

    if (pid2 == 0) {
        printf("Child 2 (PID: %d) is running 'date'...\n", getpid());
        printf("----------------------------------------\n");
        execl("/bin/date", "date", NULL);

        perror("execl for date failed");
        exit(1);
    } else {
        wait(NULL);
        printf("----------------------------------------\n");
        printf("Parent: Child 2 has finished.\n\n");
    }

    printf("Parent process done.\n");

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We call fork create a new process.
In the child child process we call "execl" for calling "ls". In the parent we wait for it to complete.
We do second fork call, which happens only in the parent process, because the child process was changed to "ls".
In the child process that was created from that fork call, we change its process image to a "date" program's one.
In the parent process we wait for the completeion of the "date" program.
And at the end print after the completeion of child processes.
The result of the prints is the following:
-----------------------------
Parent starting...

Child 1 (PID: 145678) is running 'ls' ...
----------------------------------------
multiple_fork_exec  multiple_fork_exec.c
----------------------------------------
Parent: Child 1 has finished.

Child 2 (PID: 145679) is running 'date'...
----------------------------------------
Sun Sep 14 12:33:32 UTC 2025
----------------------------------------
Parent: Child 2 has finished.

Parent process done.
-----------------------------
"ls" printed contents of the directory, "date" printed the current date.
When two processes finished parent printed that it is done.

4)fork_exec_arguments
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("Child process executing 'echo'...\n");
        printf("----------------------------------\n");

        execl("/bin/echo", "echo", "Hello from the child process", NULL);

        perror("execl failed");
        exit(1);
    }
    else {
        wait(NULL);

        printf("----------------------------------\n");
        printf("Parent process done.\n");
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We do fork, craeting a new process. Check for a failed "fork" exit with 1 code.
In the child process we replace it with "echo", which is located in "/bin/echo", using "execl". We also pass "Hello from the child process" as its first argument, and pass NULL to the "execl" as its last argument to indicate the end of argument list.
We also do "perror" for the case when "execl" fails.
The parent process waits for the child's execution and prints the message.
The result of the prints is the following:
-----------------------------
Child process executing 'echo'...
----------------------------------
Hello from the child process
----------------------------------
Parent process done.
-----------------------------
"echo" printed, what was given to it as an argument.

5)fork_exec_cmd_arguments
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("Child (PID: %d) is running 'grep main test.txt'...\n", getpid());
        printf("--------------------------------------------------\n");

        execl("/usr/bin/grep", "grep", "-n", "main", "test.txt", NULL);

        perror("execl for grep failed");
        exit(1);
    }
    else {
        wait(NULL);

        printf("--------------------------------------------------\n");
        printf("Parent process completed.\n");
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We do fork.
In the child process we call "execl", which replaces the current process image with the grep's one, which is loacted in "/usr/bin/grep".
We pass three arguments: "-n" for sowing lines, "main" as the keyword that will be searched, "test.txt" is the file where the "main" will be searched, NULL indicates the end of argument list.
"perror" and "exit" are for the case when execl fails.
Parent waits for the end of execution of the child and prints the message.
The result of the prints is the following:
-----------------------------
Child (PID: 146150) is running 'grep main test.txt'...
--------------------------------------------------
2:main
6:main
7:main
8:main
9:main
--------------------------------------------------
Parent process completed.
-----------------------------
"grep" command found 5 occourences of "main" and showed them with lines they were loacted.
