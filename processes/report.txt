1)process_fork
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("I am the child process, my PID is: %d\n", getpid());

        exit(0);
    }
    else {
        printf("I am the parent process, my PID is: %d\n", getpid());
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We create a child process using "fork". Check for the case when "fork" fails, and handle it by printing a message and exiting with code 1.
In the child process when "pid" is 0 we print the process id using "getpid", exit with code 0.
In the parent process we print the process id using "getpid". We do not wait for the child process to finish.
The result of the prints is the following:
-----------------------------
I am the parent process, my PID is: 220214
I am the child process, my PID is: 220215
-----------------------------
Here we see the parent process printed first, and then the child process. 
Which is not what would happen, if we have the parent process wait for the child process to finish. 
In that case the child process would print first, and then the parent process.

2)process_wait
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
    pid_t pid = fork();
    int status1;

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("I am the child process, my PID is: %d\n", getpid());

        sleep(2);

        exit(4);
    }
    else {
        wait(&status1);

        printf("I am the parent process, my PID is: %d\n", getpid());
    }

    pid_t pid2 = fork();
    int status2;

    if (pid2 < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid2 == 0) {
        printf("I am the child process, my PID is: %d\n", getpid());

        sleep(2);

        exit(5);
    }
    else {
        waitpid(pid2, &status2, 0);

        printf("I am the parent process, my PID is: %d\n", getpid());
    }

    if (WIFEXITED(status1)) {
        printf("Exit status of first child was: %d\n", WEXITSTATUS(status1));
    }

    if (WIFEXITED(status2)) {
        printf("Exit status of second child was: %d\n", WEXITSTATUS(status2));
    }
    
    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We create a child process using "fork". Handle the case when "fork" fails, by printing a message and exiting with code 1.
In the child process we print the process id and then sleep for 2 seconds, and then exit with code 4.
In the parent process we wait for the child process to finish using "wait", which takes an argument by reference, modifies it with the status code of the child process, and then prints the process id.
We create a second child process using "fork". Handle the case when "fork" fails. Again, in the child process we print the process id, sleep for 2 seconds, and then exit with code 5.
In the parent process we wait for the second child process to finish using "waitpid", which takes the pid of the child process, an argument by reference to modify with the status code of the child process, and options, which is 0 in this case. Then we print the process id.
At this point both child processes have finished and we have thier status codes in "status1" and "status2".
We check if the first child process exited normally using "WIFEXITED", and if it did we print its exit status using "WEXITSTATUS".
We do the same for the second child process.
The result of the prints is the following:
-----------------------------
I am the child process, my PID is: 220239
I am the parent process, my PID is: 220238
I am the child process, my PID is: 220240
I am the parent process, my PID is: 220238
Exit status of first child was: 4
Exit status of second child was: 5
-----------------------------
Here we see that the first child process printed first, then the parent process printed after the first child process finished.
Then the second child process printed, and then the parent process printed after the second child process finished.
And then status codes of the child processes are printed.

3)process_atexit
//process_atexit1
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void cleanup_function_1()
{
    printf("--- Cleanup function 1 called ---\n");
}

void cleanup_function_2()
{
    printf("--- Cleanup function 2 called ---\n");
}

int main()
{
    printf("Program starting.\n");

    atexit(cleanup_function_1);
    printf("Register cleanup_function_1\n");

    atexit(cleanup_function_2);
    printf("Register cleanup_function_2\n");

    printf("Main logic finished. Program will now terminate normally.\n");
    exit(0);

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We define two cleanup functions, "cleanup_function_1" and "cleanup_function_2", which print messages when called.
In the "main" function we print a message. Then we register "cleanup_function_1" using "atexit", which will call "cleanup_function_1" when the porgram finishes, and print a message showing that it has been registered.
Then we register "cleanup_function_2" using "atexit", and print a message showing that it has been registered.
Then we print a message telling the end of the program.
Then we call "exit" to terminate the program, which will trigger the registered cleanup functions to be called in reverse order of their registration.
The result of the prints is the following:
-----------------------------
Program starting.
Register cleanup_function_1
Register cleanup_function_2
Main logic finished. Program will now terminate normally.
--- Cleanup function 2 called ---
--- Cleanup function 1 called ---
-----------------------------
//process_atexit1

//process_atexit2
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void cleanup_function_1()
{
    printf("--- Cleanup function 1 called ---\n");
}

void cleanup_function_2()
{
    printf("--- Cleanup function 2 called ---\n");
}

int main(int argc, char *argv[])
{
    printf("Program starting.\n");

    atexit(cleanup_function_1);
    printf("Register cleanup_function_1\n");

    exit(0);
    
    atexit(cleanup_function_2);
    printf("Register cleanup_function_2\n");

    printf("Main logic finished. Program will now terminate normally.\n");

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
This code is similar to the previous one, but here we call "exit" immediately after registering "cleanup_function_1".
This means that "cleanup_function_2" is never registered, and the program terminates immediately after calling "exit".
The result of the prints is the following:
-----------------------------
Program starting.
Register cleanup_function_1
--- Cleanup function 1 called ---
-----------------------------
We see that only "cleanup_function_1" is called, and "cleanup_function_2" is never registered or called.
//process_atexit2

//process_atexit3
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void cleanup_function_1()
{
    printf("--- Cleanup function 1 called ---\n");
}

void cleanup_function_2()
{
    printf("--- Cleanup function 2 called ---\n");
}

int main(int argc, char *argv[])
{
    printf("Program starting.\n");

    exit(0);
    
    atexit(cleanup_function_1);
    printf("Register cleanup_function_1\n");

    atexit(cleanup_function_2);
    printf("Register cleanup_function_2\n");

    printf("Main logic finished. Program will now terminate normally.\n");

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
This code is similar to the previous ones, but here we call "exit" immediately at the start of the "main" function.
This means that neither "cleanup_function_1" nor "cleanup_function_2" are ever registered, and the program terminates immediately after calling "exit".
The result of the prints is the following:
-----------------------------
Program starting.
-----------------------------
//process_atexit3

"atexit" can be used to register functions that will clean some temporary files, that were created during the execution of the program, when the program terminates.
It also can be used to save the final state of the program to a file, when the program terminates.

4)fork_exit_status
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid1, pid2;
    int status;

    printf("Parent process starting with PID: %d\n", getpid());

    pid1 = fork();
    if (pid1 < 0) {
        perror("fork 1 failed");
        exit(1);
    }

    if (pid1 == 0) {
        printf("Child 1 (PID: %d) is running.\n", getpid());
        sleep(1);
        printf("Child 1 exiting with status 15.\n");
        exit(15);
    }

    pid2 = fork();
    if (pid2 < 0) {
        perror("fork 2 failed");
        exit(1);
    }

    if (pid2 == 0) {
        printf("Child 2 (PID: %d) is running.\n", getpid());
        sleep(2);
        printf("Child 2 exiting with status 25.\n");
        exit(25);
    }

    pid_t pid_arr[2] = {pid1, pid2};

    printf("Parent is now waiting for its children...\n\n");

    for (int i = 0; i < 2; i++) {
        pid_t terminated_pid = waitpid(pid_arr[i], &status, 0);

        if (terminated_pid < 0) {
            perror("waitpid failed");
            exit(1);
        }

        if (WIFEXITED(status)) {
            printf("Child with PID %d.\n", terminated_pid);
            printf("Exit code: %d\n\n", WEXITSTATUS(status));
        } 
        else {
            printf("Child with PID %d.\n", terminated_pid);
            printf("Exit code: %d\n\n", WEXITSTATUS(status));
            printf("Child exited with an error.\n\n");
        }
    }

    printf("Parent will now exit.\n");

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We print the PID of the parent process.
We create the first child process using "fork". Handle the case when "fork" fails.
In the first child process we print its PID, sleep for 1 second, print a message and then exit with code 15.
We create the second child process using "fork". Handle the case when "fork" fails.
In the second child process we print its PID, sleep for 2 seconds, print a message and then exit with code 25.
In the parent process we create an array with the PIDs of the two child processes.
We print a message indicating that the parent is waiting for its children.
We do a for loop for, which goes through the array of child pids, and for each pid we call "waitpid", which waits for the specific child process to finish, and modifies the "status" variable with the exit status of the child process.
We handle the case when "waitpid" fails.
If the child process exited normally, we print its PID and exit code.
If the child process did not exit normally, we print its PID, exit code, and a message indicating that the child exited with an error.
We print a message indicating that the parent will now exit.
The result of the prints is the following:
-----------------------------
Parent process starting with PID: 220319
Parent is now waiting for its children...

Child 1 (PID: 220320) is running.
Child 2 (PID: 220321) is running.
Child 1 exiting with status 15.
Child with PID 220320.
Exit code: 15

Child 2 exiting with status 25.
Child with PID 220321.
Exit code: 25

Parent will now exit.
-----------------------------
Here we see the parent process starting, then both child processes running.
Then the first child process exits with status 15, and the parent process prints its PID and exit code.
Then the second child process exits with status 25, and the parent process prints its PID and exit code.

5)process_zombie
//process_atexit1
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("Child (PID: %d) is created and will now exit.\n", getpid());
        
        exit(0);
    }
    else {
        printf("Parent (PID: %d) is sleeping, not waiting for child (PID: %d).\n", getpid(), pid);
        sleep(30);

        printf("Parent is done sleeping and will now exit.\n");
    }

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We create a child process using "fork". Handle the case when "fork" fails.
In the child process we print its PID and then exit immediately.
In the parent process we print its PID and the PID of the child process, and then sleep for 30 seconds without waiting for the child process to finish.
After sleeping, we print a message.
The result of the prints is the following:
-----------------------------
Parent (PID: 220340) is sleeping, not waiting for child (PID: 220341).
Child (PID: 220341) is created and will now exit.
Parent is done sleeping and will now exit.
-----------------------------
During the 30 seconds sleep of the parent process, if we check the process list using "top", we will see that the child process is in a "Z" (zombie) state, because it has exited but the parent process has not yet waited for it to finish.
Here is a part of the output of "top" command during the sleep period:
-----------------------------
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
220338 ashotp    20   0    2776   1408   1408 S   0.0   0.0   0:00.00 process_zombie_
220339 ashotp    20   0       0      0      0 Z   0.0   0.0   0:00.00 process_zombie_
-----------------------------
This could be done using "htop", "ps" commands as well, which give information about the processes and their states.
//process_atexit1

//process_atexit2
/////////////////////////////
Code
/////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        printf("Child (PID: %d) is created and will now exit.\n", getpid());

        exit(0);
    }
    else {
        printf("Parent (PID: %d) is waiting for child (PID: %d) to finish.\n", getpid(), pid);
        
        wait(NULL);

        printf("No zombie was created.\n");

	sleep(10);
    }

    printf("Parent process end.");

    return 0;
}
/////////////////////////////
Report
/////////////////////////////
We create a child process using "fork". Handle the case when "fork" fails.
In the child process we print its PID and then exit immediately.
In the parent process we print its PID and the PID of the child process, and then wait for the child process to finish using "wait".
After the child process has finished, we print a message indicating that no zombie was created.
Then we sleep for 10 seconds to check the process list.
we print a message.
The result of the prints is the following:
-----------------------------
Parent (PID: 220360) is waiting for child (PID: 220361) to finish.
Child (PID: 220361) is created and will now exit.
No zombie was created.
Parent process end.
-----------------------------
During the 10 seconds sleep of the parent process, if we check the process list using "top", we will see that the child process is not in a "Z" (zombie) state, because the parent process has already waited for it to finish.
Here is a part of the output of "top" command during the sleep period:
-----------------------------
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
220362 ashotp    20   0    2776   1408   1408 S   0.0   0.0   0:00.00 process_zombie_
-----------------------------
Here we see that only the parent process is running, and there is no zombie child process.
This could be done using "htop", "ps" commands as well.
//process_atexit2

When a child process exits, the operating system does not immediately remove it entierly, it keeps its exit status. 
If a process is in this state, it is called a "zombie" process.
The responsiblity of removing the zombie process from the process table is on the parent process.
The parent process can do this by calling "wait" or "waitpid", which will read the exit status of the child process and remove it from the process table.
When "wait" or "waitpid" is called, the parent process will block until one of its child processes exits. 
After the child process exits, the parent process will read its exit status.
After the parent process has read the exit status of the child process, the child process is removed from the process table by the kernel.
